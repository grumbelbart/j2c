#pragma once

#include <utility>

%1$s
#include <java/lang/ArrayStoreException.hpp>

class %5$sArray
%3$s{
public:
    static ::java::lang::Class *class_();
    typedef %4$sArray super;

    typedef %5$s *value_type;

    %2$sArray() { }
    %2$sArray(int n) : ::java::lang::ObjectArray(n) { }

    %2$sArray(const value_type *values, int n) : ::java::lang::ObjectArray(n)
    {
    	auto x = p;
    	for(auto v = values; v != values + n; ++v) *x++ = *v;
    }

    template<typename T>
    %2$sArray(std::initializer_list<T> l) : ::java::lang::ObjectArray(l.size())
    {
    	auto x = p;
    	for(auto v : l) *x++ = v;
    }

    %2$sArray(const %2$sArray &rhs) : ::java::lang::ObjectArray(rhs) { }
    %2$sArray(%2$sArray &&rhs) : ::java::lang::ObjectArray(std::move(rhs)) { }

    %2$sArray &operator=(const %2$sArray &rhs)
    {
    	::java::lang::ObjectArray::operator=(rhs);
    	return *this;
    }

    %2$sArray &operator=(%2$sArray &&rhs)
    {
    	::java::lang::ObjectArray::operator=(std::move(rhs));
    	return *this;
    }

    %2$sArray* clone() override { return new %2$sArray(*this); }

    value_type operator[](size_type i) const { return get(i); }
    value_type get(size_type i) const { return dynamic_cast<value_type>(p[i]); }

private:
    ::java::lang::Class *getClass0() override;
     
    void set0(size_type i, ::java::lang::Object *x) override
    {
        if(x && !dynamic_cast<value_type>(x)) {
            throw new ::java::lang::ArrayStoreException();
        }
        
        p[i] = x;
    }
};
